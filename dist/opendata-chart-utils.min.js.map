{"version":3,"file":"opendata-chart-utils.js","sources":["../src/field/is-numeric-type.js","../src/date/get-periodic-time-interval.js","../src/field/should-chart-attribute.js","../src/index.js"],"sourcesContent":["/*\n* Is a field numeric?\n* @param {string} type - Input esri field type\n* @return {boolean} - Yes/no on if field is numeric\n*/\nexport default function isNumericType (type) {\n  // NOTE: type can be one of the following:\n  // \"esriFieldTypeSmallInteger\", \"esriFieldTypeInteger\", \"esriFieldTypeSingle\", \"esriFieldTypeDouble\",\n  // \"esriFieldTypeString\",\n  // \"esriFieldTypeDate\",\n  // \"esriFieldTypeOID\", \"esriFieldTypeGlobalID\",\n  // \"esriFieldTypeGeometry\", \"esriFieldTypeBlob\", \"esriFieldTypeRaster\", \"esriFieldTypeGUID\", \"esriFieldTypeXML\"\n  const numericTypes = ['esriFieldTypeSmallInteger', 'esriFieldTypeInteger', 'esriFieldTypeSingle', 'esriFieldTypeDouble', 'esriFieldTypeFloat'];\n  return numericTypes.indexOf(type) > -1;\n}\n","import moment from 'moment';\n/**\n * How to get Periodic time intervals\n *\n  * @param {date} startDate - Starting date\n  * @param {date} endDate - Ending date\n  * @returns {string} or {null} - Returns type of time interval or null\n */\nexport default function getPeriodicTimeInterval (startDate, endDate) {\n   // Make our start / ends be wrapped in moment for comparison logic\n  const start = moment(startDate);\n  const end = moment(endDate);\n\n  if (!shouldCalcDates(startDate, endDate)) { return null; }\n\n  if (calcDiffInDates(end, start, 'year') <= 25 && calcDiffInDates(end, start, 'month') > 12) {\n    return 'year';\n  } else if (calcDiffInDates(end, start, 'month') <= 12 && calcDiffInDates(end, start, 'day') > 31) {\n    return 'month';\n  } else if (calcDiffInDates(end, start, 'day') <= 31 && calcDiffInDates(end, start, 'hour') > 24) {\n    return 'day';\n  } else if (calcDiffInDates(end, start, 'hour') <= 24 && calcDiffInDates(end, start, 'minute') > 30) {\n    return 'hour';\n  } else if (calcDiffInDates(end, start, 'minute') <= 30 && calcDiffInDates(end, start, 'second') > 30) {\n    return 'minute';\n  } else if (calcDiffInDates(end, start, 'second') <= 30 && calcDiffInDates(end, start, 'second') > 1) {\n    return 'second';\n  }\n\n  return null;\n}\n\n// Determine the differences in dates. True is needed to calc as a float.\nfunction calcDiffInDates (end, start, measureOfTime) {\n  return end.diff(start, measureOfTime, true);\n}\n\n// Should we calc a time interval even?\nfunction shouldCalcDates (start, end) {\n  // if either date is invalid return null\n  if (!validDate(start) || !validDate(end)) { return null; }\n  // if the start date is after the end date return null\n  if (!startDateAfterEndDate(start, end)) { return null; }\n  return true;\n}\n\n// Is the date valid? new Date() because moment doesn't recognize datetime objects otherwise\nfunction validDate (date) {\n  return moment.isDate(new Date(date));\n}\n\n// Is the start date after the end date?\nfunction startDateAfterEndDate (start, end) {\n  return moment(start).isBefore(end);\n}\n","import getPeriodicTimeInterval from '../date/get-periodic-time-interval';\nimport isNumericType from './is-numeric-type';\n\n/**\n * Should a chart attribute be allowed to be chartable\n * @param  {string} fieldType What is the field type?\n * @param  {object} stats     The stats object as passed in\n * @param  {object} options   Options (maxCount, advancedQueryCapabilities)\n * @return {boolean}           Yes/no on chartability\n */\nexport default function shouldChartAttribute (fieldType, stats, options) {\n  // set default options\n  let defaultOptions = {\n    maxCount: 20,\n    maxRecordCount: 10001,\n    recordCount: 10002,\n    advancedQueryCapabilities: false\n  };\n  // Merge defaults and actual options object\n  let internalOptions = Object.assign({}, defaultOptions, options);\n\n  // If stats are undefined just exit immediately\n  if (!stats) {\n    return false;\n  }\n\n  // Declare our Heuristics\n  const heuristics = {\n    fieldType,\n    durationBool: stats.duration > 0,\n    countBool: stats.count <= internalOptions.maxCount,\n    notEmptyBool: stats.count > 0,\n    allEmptyVals: stats.max === 0 && stats.min === 0,\n    sqlExpressionBool: !!internalOptions.advancedQueryCapabilities && internalOptions.advancedQueryCapabilities.supportsSqlExpression,\n    maxRecordCountBool: recordCountBool(internalOptions.recordCount, internalOptions.maxRecordCount),\n    timeIntervalBool: !!getPeriodicTimeInterval(stats.min, stats.max)\n  };\n\n  return evaluatedHeuristics(heuristics);\n}\n\n// Determine if it can be charted...\n\nfunction evaluatedHeuristics (heuristics) {\n  if (isNumericType(heuristics.fieldType)) {\n    // If numeric check that duration is greater than 0 and count is greater than 0\n    return heuristics.durationBool && heuristics.notEmptyBool && !heuristics.allEmptyVals;\n  } else if (heuristics.fieldType === 'esriFieldTypeString') {\n    // If string check that duration is greater than 0 and count is greater than 0\n    // and that count is less than or equal to maxCount\n    return heuristics.countBool && heuristics.durationBool && heuristics.notEmptyBool;\n  } else if (heuristics.fieldType === 'esriFieldTypeDate') {\n    // If date check that duration is greater than 0 and count is greater than 0\n    // and that sqlExpressions are supported\n    return heuristics.notEmptyBool && heuristics.durationBool &&\n      (heuristics.sqlExpressionBool || heuristics.maxRecordCountBool) &&\n      heuristics.timeIntervalBool;\n  }\n\n  return false;\n}\n\n// return maxRecordCount boolean\nfunction recordCountBool (recordCount, maxRecordCount) {\n  return recordCount <= maxRecordCount && recordCount <= 10000;\n}\n","import isNumericType from './field/is-numeric-type';\nimport getPeriodicTimeInterval from './date/get-periodic-time-interval';\nimport shouldChartAttribute from './field/should-chart-attribute';\n\nexport default {\n  field: {\n    isNumericType,\n    shouldChartAttribute,\n    getPeriodicTimeInterval\n  }\n};\n"],"names":["isNumericType","type","indexOf","getPeriodicTimeInterval","startDate","endDate","const","start","moment","end","shouldCalcDates","calcDiffInDates","measureOfTime","diff","validDate","startDateAfterEndDate","date","isDate","Date","isBefore","shouldChartAttribute","fieldType","stats","options","let","defaultOptions","maxCount","maxRecordCount","recordCount","advancedQueryCapabilities","internalOptions","Object","assign","evaluatedHeuristics","durationBool","duration","countBool","count","notEmptyBool","allEmptyVals","max","min","sqlExpressionBool","supportsSqlExpression","maxRecordCountBool","recordCountBool","timeIntervalBool","heuristics","field"],"mappings":"kOAKA,SAAwBA,GAAeC,GAQrC,OADsB,4BAA6B,uBAAwB,sBAAuB,sBAAuB,sBACrGC,QAAQD,IAAS,ECLvC,QAAwBE,GAAyBC,EAAWC,GAE1DC,GAAMC,GAAQC,EAAOJ,GACfK,EAAMD,EAAOH,EAEnB,OAAKK,GAAgBN,EAAWC,GAE5BM,EAAgBF,EAAKF,EAAO,SAAW,IAAMI,EAAgBF,EAAKF,EAAO,SAAW,GAC/E,OACEI,EAAgBF,EAAKF,EAAO,UAAY,IAAMI,EAAgBF,EAAKF,EAAO,OAAS,GACrF,QACEI,EAAgBF,EAAKF,EAAO,QAAU,IAAMI,EAAgBF,EAAKF,EAAO,QAAU,GACpF,MACEI,EAAgBF,EAAKF,EAAO,SAAW,IAAMI,EAAgBF,EAAKF,EAAO,UAAY,GACvF,OACEI,EAAgBF,EAAKF,EAAO,WAAa,IAAMI,EAAgBF,EAAKF,EAAO,UAAY,GACzF,SACEI,EAAgBF,EAAKF,EAAO,WAAa,IAAMI,EAAgBF,EAAKF,EAAO,UAAY,EACzF,SAGF,KAhB4C,KAoBrD,QAASI,GAAiBF,EAAKF,EAAOK,GACpC,MAAOH,GAAII,KAAKN,EAAOK,GAAe,GAIxC,QAASF,GAAiBH,EAAOE,GAE/B,MAAKK,GAAUP,IAAWO,EAAUL,KAE/BM,EAAsBR,EAAOE,IAAe,KAFE,KAOrD,QAASK,GAAWE,GAClB,MAAOR,GAAOS,OAAO,GAAIC,MAAKF,IAIhC,QAASD,GAAuBR,EAAOE,GACrC,MAAOD,GAAOD,GAAOY,SAASV,GC3ChC,QAAwBW,GAAsBC,EAAWC,EAAOC,GAE9DC,GAAIC,IACFC,SAAU,GACVC,eAAgB,MAChBC,YAAa,MACbC,2BAA2B,GAGzBC,EAAkBC,OAAOC,UAAWP,EAAgBF,EAGxD,SAAKD,GAgBEW,GAVLZ,UAAAA,EACAa,aAAcZ,EAAMa,SAAW,EAC/BC,UAAWd,EAAMe,OAASP,EAAgBJ,SAC1CY,aAAchB,EAAMe,MAAQ,EAC5BE,aAA4B,IAAdjB,EAAMkB,KAA2B,IAAdlB,EAAMmB,IACvCC,oBAAqBZ,EAAgBD,2BAA6BC,EAAgBD,0BAA0Bc,sBAC5GC,mBAAoBC,EAAgBf,EAAgBF,YAAaE,EAAgBH,gBACjFmB,mBAAoB3C,EAAwBmB,EAAMmB,IAAKnB,EAAMkB,OAQjE,QAASP,GAAqBc,GAC5B,MAAI/C,GAAc+C,EAAW1B,WAEpB0B,EAAWb,cAAgBa,EAAWT,eAAiBS,EAAWR,aACvC,wBAAzBQ,EAAW1B,UAGb0B,EAAWX,WAAaW,EAAWb,cAAgBa,EAAWT,aACnC,sBAAzBS,EAAW1B,YAGb0B,EAAWT,cAAgBS,EAAWb,eAC1Ca,EAAWL,mBAAqBK,EAAWH,qBAC5CG,EAAWD,kBAOjB,QAASD,GAAiBjB,EAAaD,GACrC,MAAOC,IAAeD,GAAkBC,GAAe,wCC3DvDoB,OACEhD,cAAAA,EACAoB,qBAAAA,EACAjB,wBAAAA"}